// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See http://js.arcgis.com/3.18/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/layers/vectorTiles/views/vectorTiles/renderers/shaders/solidFillShader.vs.glsl":"attribute vec2 a_pos;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\n\r\nvoid main()\r\n{\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0, 1.0);\r\n}\r\n","url:esri/layers/vectorTiles/views/vectorTiles/renderers/shaders/solidFillShader.fs.glsl":"uniform lowp vec4 u_color;\r\nvoid main()\r\n{\r\n  gl_FragColor \x3d u_color;\r\n}",
"url:esri/layers/vectorTiles/views/vectorTiles/renderers/shaders/patternFillShader.vs.glsl":"uniform highp mat4 u_transformMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump mat3 u_pattern_matrix; // can we use meduim precision??\r\n\r\nattribute vec2 a_pos;\r\n\r\nvarying mediump vec2 v_tileTextureCoord;\r\n\r\nvoid main()\r\n{\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0);\r\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\r\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\r\n  // (-4k to 8k -1) to texture coordinates.\r\n  v_tileTextureCoord \x3d (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\r\n}\r\n",
"url:esri/layers/vectorTiles/views/vectorTiles/renderers/shaders/patternFillShader.fs.glsl":"uniform lowp float u_opacity;\r\nuniform mediump vec2 u_pattern_tl;\r\nuniform mediump vec2 u_pattern_br;\r\nuniform sampler2D u_texture;\r\n\r\nvarying mediump vec2 v_tileTextureCoord;\r\n\r\nvoid main()\r\n{\r\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\r\n  mediump vec2 normalizedTextureCoord \x3d mod(v_tileTextureCoord, 1.0);\r\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\r\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\r\n  // we need to only sample from area that has our sprite in the mosaic.\r\n  mediump vec2 samplePos \x3d mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\r\n  // sample the sprite mosaic\r\n  lowp vec4 color \x3d texture2D(u_texture, samplePos);\r\n\r\n  // 'un-premultiply' the color\r\n  lowp float inv_alpha \x3d (1.0 / clamp(color.a, 0.00390625, 1.0));\r\n  gl_FragColor \x3d color * vec4(inv_alpha, inv_alpha, inv_alpha, u_opacity);\r\n}\r\n",
"url:esri/layers/vectorTiles/views/vectorTiles/renderers/shaders/fillOutlineShader.vs.glsl":"attribute vec2 a_pos;\r\nattribute vec2 a_offset;\r\nattribute vec2 a_xnormal;\r\n\r\nuniform highp mat4 u_transformMatrix;\r\nuniform highp mat4 u_extrudeMatrix;\r\nuniform highp vec2 u_normalized_origin;\r\nuniform mediump float u_depth;\r\nuniform mediump float u_outline_width;\r\n\r\nvarying lowp vec2 v_normal;\r\n\r\nconst float scale \x3d 1.0 / 15.0;\r\n\r\nvoid main()\r\n{\r\n  v_normal \x3d a_xnormal;\r\n\r\n   // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\r\n    // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\r\n  mediump vec4 dist \x3d vec4(u_outline_width * a_offset * scale, 0.0, 0.0);\r\n\r\n  // Remove the texture normal bit of the position before scaling it with the\r\n  // model/view matrix. Add the extrusion vector *after* the model/view matrix\r\n  // because we're extruding the line in pixel space, regardless of the current\r\n  // tile's zoom level.\r\n  gl_Position \x3d vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * dist;\r\n}\r\n",
"url:esri/layers/vectorTiles/views/vectorTiles/renderers/shaders/fillOutlineShader.fs.glsl":"uniform lowp vec4 u_color;\r\nvarying mediump vec2 v_normal;\r\n\r\nvoid main()\r\n{\r\n  // Calculate the distance of the pixel from the line in pixels.\r\n  lowp float dist \x3d abs(v_normal.y);\r\n\r\n  lowp float alpha \x3d smoothstep(1.0, 0.0, dist);\r\n  gl_FragColor \x3d vec4(u_color.rgb, u_color.a * alpha);\r\n}\r\n"}});
define("esri/layers/vectorTiles/views/vectorTiles/renderers/FillRenderer","require exports ../../../core/libs/gl-matrix/mat4 ../../../core/libs/gl-matrix/mat3 ../../../core/libs/gl-matrix/vec4 ../../../core/libs/gl-matrix/vec3 dojo/text!./shaders/solidFillShader.vs.glsl dojo/text!./shaders/solidFillShader.fs.glsl dojo/text!./shaders/patternFillShader.vs.glsl dojo/text!./shaders/patternFillShader.fs.glsl dojo/text!./shaders/fillOutlineShader.vs.glsl dojo/text!./shaders/fillOutlineShader.fs.glsl ../../webgl/Program ../../webgl/VertexArrayObject ../GeometryUtils".split(" "),function(K,
L,x,z,u,C,D,E,F,G,H,I,t,A,B){var J=1/65536;return function(){function l(){this._outlineAttributeLocations={a_pos:0,a_offset:1,a_xnormal:2};this._fillAttributeLocations={a_pos:0};this._initialized=!1;this._viewProjMat=x.create();this._offsetVector=C.create();this._patternMatrix=z.create();this._color=u.create();this._outlineColor=u.create()}l.prototype.render=function(b,c,a,d,n,e,g,l,t,v){this._initialized||this._initialize(b);var h=g.getPaintValue("fill-pattern",a),p=void 0!==h;if(!(p&&0===n)){var u=
g.getPaintValue("fill-antialias",a)&&!p,q=g.getPaintValue("fill-opacity",a),r=g.getPaintValue("fill-color",a),w=!1;if(!p){var f=r[3]*q;1===f&&0===n&&(w=!0);1>f&&1===n&&(w=!0)}if(w||0!==n){var f=e.tileTransform.transform,k=e.coordRange/512,m=g.getPaintValue("fill-translate",a);if(0!==m[0]||0!==m[1]){x.copy(this._viewProjMat,e.tileTransform.transform);var f=m[0],m=m[1],y=0,s=0,k=(1<<e.key.level)/Math.pow(2,a)*k;1===g.getPaintValue("fill-translate-anchor",a)?(s=Math.sin(B.C_DEG_TO_RAD*-d),d=Math.cos(B.C_DEG_TO_RAD*
-d),y=k*(f*d-m*s),s=k*(f*s+m*d)):(y=k*f,s=k*m);this._offsetVector[0]=y;this._offsetVector[1]=s;this._offsetVector[2]=0;x.translate(this._viewProjMat,this._viewProjMat,this._offsetVector);f=this._viewProjMat}if(d=this._getTrianglesVAO(b,e)){b.bindVAO(d);if(p){if(1===n&&(h=l.getMosaicItemPosition(h,!0)))k=e.coordRange/512/Math.pow(2,Math.round(a)-e.key.level)/v,z.identity(this._patternMatrix),p=1/(h.size[1]*k),this._patternMatrix[0]=1/(h.size[0]*k),this._patternMatrix[4]=p,l.bind(b,9729,0),b.bindProgram(this._patternFillProgram),
this._patternFillProgram.setUniformMatrix4fv("u_transformMatrix",f),this._patternFillProgram.setUniform2fv("u_normalized_origin",e.tileTransform.displayCoord),this._patternFillProgram.setUniform1f("u_depth",g.z),this._patternFillProgram.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix),this._patternFillProgram.setUniform1f("u_opacity",q),this._patternFillProgram.setUniform2f("u_pattern_tl",h.tl[0],h.tl[1]),this._patternFillProgram.setUniform2f("u_pattern_br",h.br[0],h.br[1]),this._patternFillProgram.setUniform1i("u_texture",
0),b.drawElements(4,c.triangleElementCount,5125,12*c.triangleElementStart)}else w&&(this._color[0]=r[0],this._color[1]=r[1],this._color[2]=r[2],this._color[3]=r[3]*q,b.bindProgram(this._solidFillProgram),this._solidFillProgram.setUniformMatrix4fv("u_transformMatrix",f),this._solidFillProgram.setUniform2fv("u_normalized_origin",e.tileTransform.displayCoord),this._solidFillProgram.setUniform1f("u_depth",g.z+J),this._solidFillProgram.setUniform4fv("u_color",this._color),b.drawElements(4,c.triangleElementCount,
5125,12*c.triangleElementStart)),b.bindVAO();if(u&&0<c.outlineElementCount&&1===n){a=g.getPaintValue("fill-outline-color",a);if(0===a[3]){if(1!==this._color[3])return;a=r}v=0.75/v;this._outlineColor[0]=a[0];this._outlineColor[1]=a[1];this._outlineColor[2]=a[2];this._outlineColor[3]=a[3]*q;if(q=this._getOutlineVAO(b,e))b.bindVAO(q),b.bindProgram(this._outlineProgram),this._outlineProgram.setUniformMatrix4fv("u_transformMatrix",f),this._outlineProgram.setUniformMatrix4fv("u_extrudeMatrix",t),this._outlineProgram.setUniform2fv("u_normalized_origin",
e.tileTransform.displayCoord),this._outlineProgram.setUniform1f("u_depth",g.z),this._outlineProgram.setUniform1f("u_outline_width",v),this._outlineProgram.setUniform4fv("u_color",this._outlineColor),b.drawElements(4,c.outlineElementCount,5125,12*c.outlineElementStart),b.bindVAO()}}}}};l.prototype._initialize=function(b){if(this._initialized)return!0;var c=new t(b,D,E,{a_pos:0});if(!c)return!1;var a=new t(b,F,G,this._fillAttributeLocations);if(!a)return!1;b=new t(b,H,I,this._outlineAttributeLocations);
this._solidFillProgram=c;this._patternFillProgram=a;this._trianglesVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]};this._outlineProgram=b;this._outlineVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:8,normalized:!1,divisor:0},{name:"a_xnormal",count:2,type:5120,offset:6,stride:8,normalized:!1,divisor:0}]};return this._initialized=!0};l.prototype._getTrianglesVAO=
function(b,c){if(c.polygonTrianglesVertexArrayObject)return c.polygonTrianglesVertexArrayObject;var a=c.polygonTrianglesVertexBuffer,d=c.polygonTrianglesIndexBuffer;if(!a||!d)return null;c.polygonTrianglesVertexArrayObject=new A(b,this._fillAttributeLocations,this._trianglesVertexAttributes,{geometry:a},d);return c.polygonTrianglesVertexArrayObject};l.prototype._getOutlineVAO=function(b,c){if(c.polygonOutlineVertexArrayObject)return c.polygonOutlineVertexArrayObject;var a=c.polygonOutlinesVertexBuffer,
d=c.polygonOutlinesIndexBuffer;if(!a||!d)return null;c.polygonOutlineVertexArrayObject=new A(b,this._outlineAttributeLocations,this._outlineVertexAttributes,{geometry:a},d);return c.polygonOutlineVertexArrayObject};return l}()});